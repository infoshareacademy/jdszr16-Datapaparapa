import streamlit as st
import pandas as pd
import plotly.express as px
import re
from datetime import datetime

# Funkcja do usuwania emotikon√≥w
def remove_emoji(text):
    emoji_pattern = re.compile(
        "["
        "\U0001F600-\U0001F64F"  # Emotikony twarzy
        "\U0001F300-\U0001F5FF"  # Symbole i piktogramy
        "\U0001F680-\U0001F6FF"  # Transport i symbole map
        "\U0001F1E0-\U0001F1FF"  # Flagi
        "]+", flags=re.UNICODE)
    return emoji_pattern.sub(r'', text)

# Funkcja do obliczania LTV na u≈ºytkownika
def calculate_ltv(df):
    # Zak≈Çadamy, ≈ºe LTV = suma zakup√≥w / liczba dni od pierwszego zakupu
    df['First_Purchase'] = df.groupby('user_id')['event_time'].transform('min')
    df['Days_Since_First_Purchase'] = (df['event_time'] - df['First_Purchase']).dt.days
    df['Days_Since_First_Purchase'] = df['Days_Since_First_Purchase'].replace(0, 1)  # Unikamy dzielenia przez zero
    df['LTV'] = df['price'] / df['Days_Since_First_Purchase']
    ltv_df = df.groupby('user_id').agg(
        Total_Revenue=('price', 'sum'),
        Total_Days=('Days_Since_First_Purchase', 'max'),
        LTV=('LTV', 'sum')
    ).reset_index()
    return ltv_df

# Funkcja do obliczania RFM
def calculate_rfm(df, reference_date):
    rfm_df = df.groupby('user_id').agg({
        'event_time': lambda x: (reference_date - x.max()).days,
        'user_id': 'count',
        'price': 'sum'
    }).rename(columns={
        'event_time': 'Recency',
        'user_id': 'Frequency',
        'price': 'Monetary'
    }).reset_index()
    return rfm_df

# Funkcja do segmentacji RFM
def rfm_segment(rfm):
    segments = []
    for _, row in rfm.iterrows():
        score = ''
        # Recency
        if row['Recency'] <= 30:
            score += '4'
        elif row['Recency'] <= 60:
            score += '3'
        elif row['Recency'] <= 90:
            score += '2'
        else:
            score += '1'
        # Frequency
        if row['Frequency'] >= 10:
            score += '4'
        elif row['Frequency'] >= 7:
            score += '3'
        elif row['Frequency'] >= 4:
            score += '2'
        else:
            score += '1'
        # Monetary
        if row['Monetary'] >= 1000:
            score += '4'
        elif row['Monetary'] >= 500:
            score += '3'
        elif row['Monetary'] >= 200:
            score += '2'
        else:
            score += '1'
        # Segmentacja na podstawie RFM Score
        if score == '444':
            segments.append('Champion')
        elif score.startswith('4') and score.endswith('3'):
            segments.append('Loyal Customer')
        elif score.startswith('3') and score.endswith('2'):
            segments.append('Potential Loyalist')
        elif score.startswith('2') and score.endswith('1'):
            segments.append('At Risk')
        else:
            segments.append('Others')
    rfm['Segment'] = segments
    return rfm

# Konfiguracja strony
st.set_page_config(page_title="üìä Dashboard - Analiza Danych", layout="wide")
st.title("üìà Dashboard - Analiza Danych")

# Sprawdzenie, czy plik zosta≈Ç wgrany
if 'df_sales' not in st.session_state:
    st.warning("üö´ Proszƒô wgraƒá plik CSV na stronie g≈Ç√≥wnej.")
    st.stop()

df_sales = st.session_state['df_sales']

try:
    # Konwersja event_time na datetime
    df_sales['event_time'] = pd.to_datetime(df_sales['event_time'])
except Exception as e:
    st.error(f"‚ùå Nie uda≈Ço siƒô przetworzyƒá kolumny 'event_time': {e}")
    st.stop()

# Wyb√≥r zakresu dat
min_date = df_sales['event_time'].min().date()
max_date = df_sales['event_time'].max().date()

start_date, end_date = st.date_input(
    "üìÖ Wybierz zakres dat",
    [min_date, max_date],
    min_value=min_date,
    max_value=max_date
)

if start_date > end_date:
    st.error("‚ùó Data poczƒÖtkowa nie mo≈ºe byƒá p√≥≈∫niejsza ni≈º data ko≈Ñcowa.")
else:
    # Filtrowanie danych po zakresie dat
    filtered_df = df_sales[(df_sales['event_time'].dt.date >= start_date) &
                           (df_sales['event_time'].dt.date <= end_date)]

    if filtered_df.empty:
        st.warning("‚ö†Ô∏è Brak danych dla wybranego zakresu dat.")
    else:
        # Obliczenia podstawowych metryk
        total_transactions = filtered_df.shape[0]
        total_revenue = filtered_df['price'].sum()
        average_transaction_value = filtered_df['price'].mean()
        unique_users = filtered_df['user_id'].nunique()
        average_transactions_per_user = total_transactions / unique_users if unique_users else 0
        ltv = total_revenue / unique_users if unique_users else 0

        # Wy≈õwietlenie metryk w 3 kolumnach
        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric("üì¶ Ca≈Çkowita liczba transakcji", total_transactions)
            st.divider()
            st.metric("üõí ≈örednia liczba zakup√≥w na u≈ºytkownika", f"{average_transactions_per_user:.2f}")

        with col2:
            st.metric("üí∞ Ca≈Çkowita warto≈õƒá transakcji", f"${total_revenue:,.2f}")
            st.divider()
            st.metric("üîÑ Customer Lifetime Value (LTV)", f"${ltv:,.2f}")

        with col3:
            st.metric("üíµ ≈örednia warto≈õƒá jednej transakcji", f"${average_transaction_value:,.2f}")
            st.divider()
            st.metric("üë• Liczba unikalnych u≈ºytkownik√≥w", unique_users)

        # Analiza zakup√≥w wg godzin, dni tygodnia i miesiƒôcy
        cart_data = filtered_df[filtered_df['event_type'] == 'purchase']

        if not cart_data.empty:
            cart_data['hour'] = cart_data['event_time'].dt.hour
            cart_data['day_of_week'] = cart_data['event_time'].dt.day_name()
            cart_data['month'] = cart_data['event_time'].dt.month_name()

            # Sortowanie dni tygodnia
            day_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
            cart_data['day_of_week'] = pd.Categorical(cart_data['day_of_week'], categories=day_order, ordered=True)

            # Sortowanie miesiƒôcy chronologicznie
            month_order = ["January", "February", "March", "April", "May", "June",
                           "July", "August", "September", "October", "November", "December"]
            cart_data['month'] = pd.Categorical(cart_data['month'], categories=month_order, ordered=True)
            cart_data = cart_data.sort_values('month')

            # Suma warto≈õci zakup√≥w wg godzin (Plotly)
            hourly_revenue = cart_data.groupby('hour')['price'].sum().reset_index()
            fig_hourly = px.bar(hourly_revenue, x='hour', y='price',
                                labels={'hour': 'Godzina', 'price': 'Suma warto≈õci zakup√≥w'},
                                title="‚è∞ Suma warto≈õci zakup√≥w wg godzin",
                                color_discrete_sequence=["#636EFA"])
            st.plotly_chart(fig_hourly)

            # Suma warto≈õci zakup√≥w wg dni tygodnia (Plotly)
            daily_revenue = cart_data.groupby('day_of_week')['price'].sum().reset_index()
            fig_daily = px.bar(daily_revenue, x='day_of_week', y='price',
                               labels={'day_of_week': 'Dzie≈Ñ tygodnia', 'price': 'Suma warto≈õci zakup√≥w'},
                               title="üìÖ Suma warto≈õci zakup√≥w wg dni tygodnia",
                               color_discrete_sequence=["#EF553B"])
            st.plotly_chart(fig_daily)

            # Suma warto≈õci zakup√≥w wg miesiƒôcy (Plotly)
            monthly_revenue = cart_data.groupby('month')['price'].sum().reset_index()
            fig_monthly = px.bar(monthly_revenue, x='month', y='price',
                                 labels={'month': 'MiesiƒÖc', 'price': 'Suma warto≈õci zakup√≥w'},
                                 title="üìÜ Suma warto≈õci zakup√≥w wg miesiƒôcy",
                                 color_discrete_sequence=["#00CC96"])
            st.plotly_chart(fig_monthly)
        else:
            st.info("‚ÑπÔ∏è Brak danych zakupowych w wybranym zakresie dat.")

        st.divider()

        # Sekcja Analiza LTV
        st.header("üìä Analiza Lifetime Value (LTV)")

        # Obliczenie LTV na u≈ºytkownika
        ltv_df = calculate_ltv(filtered_df)

        # Wy≈õwietlenie podstawowych metryk LTV
        st.subheader("üîç Podstawowe Metryki LTV")
        total_ltv = ltv_df['LTV'].sum()
        average_ltv = ltv_df['LTV'].mean()
        median_ltv = ltv_df['LTV'].median()
        st.metric("üíé Ca≈Çkowity LTV wszystkich klient√≥w", f"${total_ltv:,.2f}")
        st.metric("üìà ≈öredni LTV na klienta", f"${average_ltv:,.2f}")
        st.metric("üìä Mediana LTV", f"${median_ltv:,.2f}")

        # Wizualizacja rozk≈Çadu LTV
        st.subheader("üìâ Rozk≈Çad LTV klient√≥w")
        fig_ltv = px.histogram(ltv_df, x='LTV', nbins=30,
                               labels={'LTV': 'Lifetime Value (LTV)'},
                               title="üìà Histogram LTV klient√≥w",
                               color_discrete_sequence=["#AB63FA"])
        st.plotly_chart(fig_ltv)

        # Segmentacja LTV
        st.subheader("üîó Segmentacja klient√≥w na podstawie LTV")

        # Definiowanie progu segmentacji
        ltv_thresholds = st.slider("üìä Wybierz progi segmentacji LTV", min_value=float(ltv_df['LTV'].min()),
                                   max_value=float(ltv_df['LTV'].max()),
                                   value=(ltv_df['LTV'].quantile(0.25), ltv_df['LTV'].quantile(0.75)))

        low_threshold, high_threshold = ltv_thresholds

        def segment_ltv(ltv):
            if ltv >= high_threshold:
                return 'üíé High LTV'
            elif ltv >= low_threshold:
                return 'üí∞ Medium LTV'
            else:
                return 'üìâ Low LTV'

        ltv_df['LTV_Segment'] = ltv_df['LTV'].apply(segment_ltv)

        # Wy≈õwietlenie liczby klient√≥w w ka≈ºdym segmencie
        segment_counts = ltv_df['LTV_Segment'].value_counts().reset_index()
        segment_counts.columns = ['LTV_Segment', 'Count']


        # PrzeglƒÖdanie klient√≥w w poszczeg√≥lnych segmentach
        st.subheader("üë• Klienci w poszczeg√≥lnych segmentach LTV")
        selected_segment = st.selectbox("üìÇ Wybierz segment LTV do wy≈õwietlenia",
                                       options=segment_counts['LTV_Segment'].unique())
        segment_users = ltv_df[ltv_df['LTV_Segment'] == selected_segment]
        st.write(f"**{selected_segment}** - {segment_users.shape[0]} klient√≥w")
        st.dataframe(segment_users[['user_id', 'Total_Revenue', 'Total_Days', 'LTV']].sort_values('LTV', ascending=False).reset_index(drop=True))

        st.divider()


        # Sekcja Pobierania Danych
        st.header("üíæ Pobierz Wyniki Analizy")

        # Przygotowanie danych do pobrania
        # Kopiowanie DataFrame bez emotikon√≥w w segmentacji
        ltv_no_emoji = ltv_df.copy()
        ltv_no_emoji['LTV_Segment'] = ltv_no_emoji['LTV_Segment'].apply(remove_emoji)

        # Mo≈ºliwo≈õƒá pobrania LTV
        st.subheader("üíé Pobierz dane LTV klient√≥w")
        csv_ltv = ltv_no_emoji.to_csv(index=False, encoding='utf-8-sig')
        st.download_button(
            label="üíæ Pobierz LTV jako CSV",
            data=csv_ltv,
            file_name='ltv_klientow.csv',
            mime='text/csv',
        )


